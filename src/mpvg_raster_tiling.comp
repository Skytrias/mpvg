#version 450 core

layout(local_size_x = 32, local_size_y = 32) in;
layout(rgba8, binding = 0) uniform image2D img_output;

uniform int tiles_x;
uniform int tiles_y;
uniform int tiles_size;

// kind of curve
#define C_LINE 0
#define C_QUADRATIC 1
#define C_CUBIC 2

// orientation of curve
#define C_BL 0
#define C_BR 1
#define C_TL 2
#define C_TR 3

// kind of operation
#define OPERATION_START 0
#define OPERATION_SEGMENT 1

struct Implicit_Curve {
	vec4 box;
	
	vec2 hull_vertex;
	vec2 hull_padding;

	int kind;
	int orientation;
	int sign;
	int winding_increment;

	mat3 implicit_matrix;
};

struct Tile {
	int winding_offset;
	int op_first;
	int op_last;
	bool had_cross_right;
};

struct Operation {
	int kind;
	int op_next;
	int path_index;
	int curve_index;

	bool cross_right;
	int pad1;
	int pad2;
	int pad3;
};

struct Path {
	vec4 color;
};

layout(std140, binding = 0) volatile buffer Input_Indices {
	int implicit_curves;
	int operations;
	int pad1;
	int pad2;
} indices;

layout(std140, binding = 2) readonly buffer Input_Implicit_Curves {
	Implicit_Curve data[];
} implicit_curves;

layout(std140, binding = 3) readonly buffer Tiles {
	Tile data[];
} tiles;

layout(std140, binding = 4) readonly buffer Operations {
	Operation data[];
} operations;

layout(std140, binding = 5) readonly buffer Paths {
	Path data[];
} paths;

float ccw(vec2 a, vec2 b, vec2 c) {
	return((b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x));
}

int curve_side(Implicit_Curve curve, vec2 pt) {
	int side = 0;

	// pt.y inside box
	if (pt.y > curve.box.w || pt.y <= curve.box.y) {
		// pt.x inside box
		if (pt.x > curve.box.x && pt.x <= curve.box.z) {
			// pt.y really inside
			if (pt.y > curve.box.w) {
				side = (curve.orientation == C_TL || curve.orientation == C_BR) ? -1 : 1;
			}	else {
				side = (curve.orientation == C_TL || curve.orientation == C_BR) ? 1 : -1;
			}
		}
	} else if(pt.x > curve.box.z) {
		// pt.x to right of the curve
		side = 1;
	} else if(pt.x <= curve.box.x) {
		// pt.x to left of the curve
		side = -1;
	} else {
		vec2 a, b;

		switch (curve.orientation) {
			case C_TL: {
				a = curve.box.xy;
				b = curve.box.zw;
				break;
			}

			case C_BR: {
				a = curve.box.zw;
				b = curve.box.xy;
				break;
			}

			case C_TR: {
				a = curve.box.xw;
				b = curve.box.zy;
				break;
			}

			case C_BL: {
				a = curve.box.zy;
				b = curve.box.xw;
				break;
			}
		}

		vec2 c = curve.hull_vertex;

		if (ccw(a, b, pt) < 0) {
			// other side of the diagonal
			side = (curve.orientation == C_BR || curve.orientation == C_TR) ? -1 : 1;
		}	else if(ccw(b, c, pt) < 0 || ccw(c, a, pt) < 0) {
			// same side of the diagonal, but outside curve hull
			side = (curve.orientation == C_BL || curve.orientation == C_TL) ? -1 : 1;
		}	else {
			// inside curve hull
			switch(curve.kind) {
				case C_LINE:
					side = 1;
					break;

				case C_QUADRATIC: {
					vec3 ph = vec3(pt.x, pt.y, 1);
					vec3 klm = curve.implicit_matrix * ph;
					side = ((klm.x*klm.x - klm.y)*klm.z < 0) ? -1 : 1;
				} break;

				case C_CUBIC: {
					vec3 ph = vec3(pt.x, pt.y, 1);
					vec3 klm = curve.implicit_matrix * ph;
					side = (curve.sign * (klm.x*klm.x*klm.x - klm.y*klm.z) < 0)? -1 : 1;
				} break;
			}
		}
	}

	return(side);
}

void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 px = gl_GlobalInvocationID.xy;

	uint tile_index = gl_WorkGroupID.x + gl_WorkGroupID.y * tiles_x;
	Tile tile = tiles.data[tile_index];

	int path_index = 0;
	int winding_number = tile.winding_offset;
	int op_index = tile.op_first;

	// iterate only added operations
	while (op_index != -1) {
		Operation op = operations.data[op_index];

		if (op.kind == OPERATION_START) {
			path_index = op.path_index;
		} else if (op.kind == OPERATION_SEGMENT) {
			Implicit_Curve curve = implicit_curves.data[op.curve_index];
	
			// normal curve winding 
			int side = curve_side(curve, px);
			if (px.y > curve.box.y && px.y <= curve.box.w) {
				if (side < 0) {
					winding_number += curve.winding_increment;
				} 
			}

			// apply command crosses
			if (op.cross_right) {
				if ((curve.orientation == C_BR || curve.orientation == C_TL) && (px.y > curve.box.w)) {
					winding_number += curve.winding_increment;
				} else if( (curve.orientation == C_BL || curve.orientation == C_TR) && (px.y > curve.box.y)) {
					winding_number -= curve.winding_increment;
				}
			}
		}
		
		op_index = op.op_next;
	}

	Path path = paths.data[path_index];
	vec4 color = vec4(1);

	// TODO fill / stroke?
	if ((winding_number & 1) == 1) {
		color = path.color;
	}

	if (pixel_coords.x % tiles_size == 0 || pixel_coords.y % tiles_size == 0) {
		color = vec4(0, 0, 0, 1);
	}

	imageStore(img_output, pixel_coords, color);
}