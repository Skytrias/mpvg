layout(rgba8, binding = 0) uniform image2D img_output;

void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 px = gl_GlobalInvocationID.xy;

	// OLD
	// uint tile_index = gl_WorkGroupID.x + gl_WorkGroupID.y * indices.tiles_x;

	ivec2 tile_coord = ivec2(gl_GlobalInvocationID.xy);
	uint tile_index = tile_coord.y * gl_NumWorkGroups.x + tile_coord.x;

	int path_index = 0;
	int op_index = screen_tiles.data[tile_index];
	int winding = 0;

	// iterate only added operations
	while (op_index != -1) {
		Tile_Operation op = tile_operations.data[op_index];

		if (op.kind == OPERATION_START) {
			winding = op.cross_right;
			path_index = op.path_index;
		} else if (op.kind == OPERATION_SEGMENT) {
			Implicit_Curve curve = implicit_curves.data[op.curve_index];
	
			// normal curve winding 
			int side = curve_side(curve, px);
			if (px.y > curve.box.y && px.y <= curve.box.w) {
				if (side < 0) {
					winding += curve.winding_increment;
				} 
			}

			// apply command crosses
			if (op.cross_right != 0) {
				if ((curve.orientation == C_BR || curve.orientation == C_TL) && (px.y > curve.box.w)) {
					winding += curve.winding_increment;
				} else if( (curve.orientation == C_BL || curve.orientation == C_TR) && (px.y > curve.box.y)) {
					winding -= curve.winding_increment;
				}
			}
		}
		
		op_index = -1;
		// op_index = op.op_next;
	}

	Path path = paths.data[path_index];
	vec4 color = vec4(1, 1, 1, 1);
	vec4 clip = path.clip;

	// TODO fill / stroke?
	if (px.x >= clip.x && px.x < clip.z && px.y >= clip.y && px.y < clip.w) {
		if ((winding & 1) == 1) {
			color = path.color;
		}
	}

	if (pixel_coords.x % TILE_SIZE == 0 || pixel_coords.y % TILE_SIZE == 0) {
		color = vec4(0, 0, 0, 1);
	}

	imageStore(img_output, pixel_coords, color);
}