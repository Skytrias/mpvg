#version 450 core

layout(local_size_x = 32, local_size_y = 32) in;
layout(rgba8, binding = 0) uniform image2D img_output;

uniform int color_mode;
uniform int fill_rule;

// kind of curve
#define C_LINE 0
#define C_QUADRATIC 1
#define C_CUBIC 2

// orientation of curve
#define C_BL 0
#define C_BR 1
#define C_TL 2
#define C_TR 3

struct Implicit_Curve {
	vec4 box;
	
	vec2 hull_vertex;
	vec2 hull_padding;

	int kind;
	int orientation;
	int sign;
	int winding_increment;

	mat3 implicit_matrix;
};

struct Tile {
	int winding_offset;
	int command_first;
	int command_last;
	bool had_cross_right;
};

struct Command {
	int curve_index;
	int command_next;
	bool cross_right;
	int pad1;
};

layout(std140, binding = 0) volatile buffer Input_Indices {
	int implicit_curves;
	int commands;
	int pad1;
	int pad2;
} indices;

layout(std140, binding = 2) readonly buffer Input_Implicit_Curves {
	Implicit_Curve data[];
} implicit_curves;

layout(std140, binding = 3) readonly buffer Tiles {
	Tile data[];
} tiles;

layout(std140, binding = 4) readonly buffer Commands {
	Command data[];
} commands;

float ccw(vec2 a, vec2 b, vec2 c) {
	return((b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x));
}

int curve_side(Implicit_Curve curve, vec2 pt) {
	int side = 0;

	// pt.y inside box
	if (pt.y > curve.box.w || pt.y <= curve.box.y) {
		// pt.x inside box
		if (pt.x > curve.box.x && pt.x <= curve.box.z) {
			// pt.y really inside
			if (pt.y > curve.box.w) {
				side = (curve.orientation == C_TL || curve.orientation == C_BR) ? -1 : 1;
			}	else {
				side = (curve.orientation == C_TL || curve.orientation == C_BR) ? 1 : -1;
			}
		}
	} else if(pt.x > curve.box.z) {
		// pt.x to right of the curve
		side = 1;
	} else if(pt.x <= curve.box.x) {
		// pt.x to left of the curve
		side = -1;
	} else {
		vec2 a, b;

		switch (curve.orientation) {
			case C_TL: {
				a = curve.box.xy;
				b = curve.box.zw;
				break;
			}

			case C_BR: {
				a = curve.box.zw;
				b = curve.box.xy;
				break;
			}

			case C_TR: {
				a = curve.box.xw;
				b = curve.box.zy;
				break;
			}

			case C_BL: {
				a = curve.box.zy;
				b = curve.box.xw;
				break;
			}
		}

		vec2 c = curve.hull_vertex;

		if (ccw(a, b, pt) < 0) {
			// other side of the diagonal
			side = (curve.orientation == C_BR || curve.orientation == C_TR) ? -1 : 1;
		}	else if(ccw(b, c, pt) < 0 || ccw(c, a, pt) < 0) {
			// same side of the diagonal, but outside curve hull
			side = (curve.orientation == C_BL || curve.orientation == C_TL) ? -1 : 1;
		}	else {
			// inside curve hull
			switch(curve.kind) {
				case C_LINE:
					side = 1;
					break;

				case C_QUADRATIC: {
					vec3 ph = vec3(pt.x, pt.y, 1);
					vec3 klm = curve.implicit_matrix * ph;
					side = ((klm.x*klm.x - klm.y)*klm.z < 0) ? -1 : 1;
				} break;

				case C_CUBIC: {
					vec3 ph = vec3(pt.x, pt.y, 1);
					vec3 klm = curve.implicit_matrix * ph;
					side = (curve.sign * (klm.x*klm.x*klm.x - klm.y*klm.z) < 0)? -1 : 1;
				} break;
			}
		}
	}

	return(side);
}

// fill rules
#define RULE_ODD 0
#define RULE_EVEN 1
#define RULE_NONZERO 2
#define RULE_ZERO 3

bool intersects(int rule, int intersections) {
	if (rule == RULE_ODD) {
		return (intersections & 1) == 1;
	} else if (rule == RULE_EVEN) {
		return (intersections & 1) == 0;
	} else if (rule == RULE_NONZERO) {
		return intersections != 0;
	} else if (rule == RULE_ZERO) {
		return intersections == 0;
	}

	return false;
}

vec4 colors_positive[3] = vec4[](
	vec4(1, 0, 0, 1),
	vec4(0, 1, 0, 1),
	vec4(0, 0, 1, 1)
);

vec4 colors_negative[3] = vec4[](
	vec4(0.5, 0, 0, 1),
	vec4(0, 0.5, 0, 1),
	vec4(0, 0, 0.5, 1)
);

void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 px = gl_GlobalInvocationID.xy;

	uint tile_index = gl_WorkGroupID.x + gl_WorkGroupID.y * 25;
	Tile tile = tiles.data[tile_index];

	int winding_number = tile.winding_offset;
	int cmd_index = tile.command_first;

	while (cmd_index != -1) {
		Command cmd = commands.data[cmd_index];
		Implicit_Curve curve = implicit_curves.data[cmd.curve_index];

		int side = curve_side(curve, px);
		if (px.y > curve.box.y && px.y <= curve.box.w) {
			if (side < 0) {
				winding_number += curve.winding_increment;
			} 
		}

		if (cmd.cross_right) {
			if ((curve.orientation == C_BR || curve.orientation == C_TL) && (px.y > curve.box.w)) {
				winding_number += curve.winding_increment;
			} else if( (curve.orientation == C_BL || curve.orientation == C_TR) && (px.y > curve.box.y)) {
				winding_number -= curve.winding_increment;
			}
		}

		cmd_index = cmd.command_next;
	}

	vec4 color = vec4(1, 1, 1, 1);

	if (intersects(fill_rule, winding_number)) {
		color = vec4(0, 0, 0, 1);

		if (abs(winding_number) <= 3) {
			if (winding_number < 0) {
				color = colors_negative[abs(winding_number) - 1];
			} else {
				color = colors_positive[winding_number - 1];
			}
		}

		if (color_mode == 0) {
			color = vec4(1, 0, 0, 1);
		} else if (color_mode == 1) {
			float tile_unit = tile_index / float(625);

			color = vec4(
				mod(tile_unit + 0.2, 1),
				mod(tile_unit + 0.4, 1),
				mod(tile_unit + 0.6, 1),
				1
			);
		} else if (color_mode == 2) {
			color.a = abs(winding_number) / 1.8;
		} else if (color_mode == 3) {
			color = vec4(1, 0, 0, 1);

			// highlight wanted levels
			if (winding_number > 50) {
				color = vec4(0, 1, 0, 1);
			}
		}

		if (pixel_coords.x % 32 == 0 || pixel_coords.y % 32 == 0) {
			color = vec4(0, 0, 0, 1);
		}
	}

	imageStore(img_output, pixel_coords, color);
}