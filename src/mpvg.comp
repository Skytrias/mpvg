#version 450 core

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba8, binding = 0) uniform image2D img_output;

// kind of curve
#define C_LINE 0
#define C_QUADRATIC 1
#define C_CUBIC 2

// orientation of curve
#define C_BL 0
#define C_BR 1
#define C_TL 2
#define C_TR 3

struct Implicit_Curve {
	vec2 bmin;
	vec2 bmax;
	
	mat4 M;

	vec2 base;
	vec2 E;

	int kind;
	int orientation;
	bool negative;
	bool geom_to_left;

	bool out_is_left;
	int pad1;
	int pad2;
	int pad3;
};

layout(std140, binding = 0) buffer Curves {
	Implicit_Curve data[];
} curves;

float ccw(vec2 p, vec2 a, vec2 b) {
	float d00 = p.x - a.x;
	float d01 = p.y - a.y;
	float d10 = b.x - a.x;
	float d11 = b.y - a.y;
	return d00 * d11 - d01 * d10;
}

bool going_right(Implicit_Curve curve) { 
	return curve.orientation == C_TR || curve.orientation == C_BR;
}

bool going_up(Implicit_Curve curve) { 
	return curve.orientation == C_TL || curve.orientation == C_TR;
}

int curve_eval(Implicit_Curve curve, vec2 pt) {
	int side = 0;
	if (pt.y > curve.bmax.y || pt.y <= curve.bmin.y) {
		if (pt.x > curve.bmin.x && pt.x <= curve.bmax.x) {
			if (pt.y > curve.bmax.y) {
				side = (curve.orientation == C_TL || curve.orientation == C_BR) ? -1 : 1;
			}	else {
				side = (curve.orientation == C_TL || curve.orientation == C_BR) ? 1 : -1;
			}
		}
	} else if(pt.x > curve.bmax.x) {
		side = 1;
	} else if(pt.x <= curve.bmin.x) {
		side = -1;
	} else {
		vec2 a, b, c;

		switch (curve.kind) {
		case C_TL: 
			a = curve.bmin;
			b = curve.bmax;
			break;

		case C_BR:
			a = curve.bmax;
			b = curve.bmin;
			break;

		case C_TR:
			a = vec2(curve.bmin.x, curve.bmax.y);
			b = vec2(curve.bmax.x, curve.bmin.y);
			break;

		case C_BL:
			a = vec2(curve.bmax.x, curve.bmin.y);
			b = vec2(curve.bmin.x, curve.bmax.y);
			break;
		}

		c = curve.E;

		if (ccw(a, b, pt) < 0) {
			// other side of the diagonal
			side = (curve.orientation == C_BR || curve.orientation == C_TR) ? -1 : 1;
		}	else if(ccw(b, c, pt) < 0 || ccw(c, a, pt) < 0) {
			// same side of the diagonal, but outside curve hull
			side = (curve.orientation == C_BL || curve.orientation == C_TL) ? -1 : 1;
		}	else {
			// inside curve hull
			switch(curve.kind) {
				case C_LINE:
					side = 1;
					break;

				case C_QUADRATIC: {
					vec4 ph = vec4(pt.x, pt.y, 1, 1);
					vec4 klm = curve.M * ph;
					side = ((klm.x*klm.x - klm.y)*klm.z < 0) ? -1 : 1;
				} break;

				case C_CUBIC: {
					vec4 ph = vec4(pt.x, pt.y, 1, 1);
					vec4 klm = curve.M * ph;
					int sign = int(curve.negative);
					side = (sign * (klm.x*klm.x*klm.x - klm.y*klm.z) < 0)? -1 : 1;
				} break;
			}
		}
	}

	return(side);
}

// fill rules
#define RULE_ODD 1
#define RULE_EVEN 2
#define RULE_NONZERO 3
#define RULE_ZERO 4

bool intersects(int rule, int intersections) {
	if (rule == RULE_ODD) {
		return (intersections & 1) == 1;
	} else if (rule == RULE_EVEN) {
		return (intersections & 1) == 0;
	} else if (rule == RULE_NONZERO) {
		return intersections != 0;
	} else if (rule == RULE_ZERO) {
		return intersections == 0;
	}

	return false;
}

void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 px = gl_GlobalInvocationID.xy;

	int winding_number = 0;
	for (int i = 0; i < curves.data.length(); i += 1) {
		Implicit_Curve curve = curves.data[i];
		winding_number += curve_eval(curve, px);
	}

	vec4 color = vec4(1, 1, 1, 1);

	// if (intersects(RULE_ODD, winding_number)) {
	// if (intersects(RULE_EVEN, winding_number)) {
	if (intersects(RULE_NONZERO, winding_number)) {
	// if (intersects(RULE_ZERO, winding_number)) {
		color = vec4(1, 0, 0, 1);
	}
	
	imageStore(img_output, pixel_coords, color);
}