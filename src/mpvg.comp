#version 450 core

layout(local_size_x = 32, local_size_y = 32) in;
layout(rgba8, binding = 0) uniform image2D img_output;

// kind of curve
#define C_LINE 0
#define C_QUADRATIC 1
#define C_CUBIC 2

// orientation of curve
#define C_BL 0
#define C_BR 1
#define C_TL 2
#define C_TR 3

struct Tile {
	int winding_number;
	bool skip;
	int pad1;
	int pad2;
	vec4 color;
};

layout(std140, binding = 1) buffer Tiles {
	Tile data[];
} tiles;

struct Implicit_Curve {
	vec4 box;
	
	mat4 M;

	vec2 base;
	vec2 E;

	int kind;
	int orientation;
	bool negative;
	bool going_up;
};

layout(std140, binding = 0) buffer Curves {
	Implicit_Curve data[];
} curves;

float ccw(vec2 a, vec2 b, vec2 c) {
	return((b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x));
}

int curve_eval(Implicit_Curve curve, vec2 pt) {
	int side = 0;
	if (pt.y > curve.box.w || pt.y <= curve.box.y) {
		if (pt.x > curve.box.x && pt.x <= curve.box.z) {
			if (pt.y > curve.box.w) {
				side = (curve.orientation == C_TL || curve.orientation == C_BR) ? -1 : 1;
			}	else {
				side = (curve.orientation == C_TL || curve.orientation == C_BR) ? 1 : -1;
			}
		}
	} else if(pt.x > curve.box.z) {
		side = 1;
	} else if(pt.x <= curve.box.x) {
		side = -1;
	} else {
		vec2 a, b;

		switch (curve.orientation) {
			case C_TL: {
				a = curve.box.xy;
				b = curve.box.zw;
				break;
			}

			case C_BR: {
				a = curve.box.zw;
				b = curve.box.xy;
				break;
			}

			case C_TR: {
				a = curve.box.xw;
				b = curve.box.zy;
				break;
			}

			case C_BL: {
				a = curve.box.zy;
				b = curve.box.xw;
				break;
			}
		}

		vec2 c = curve.E;

		if (ccw(a, b, pt) < 0) {
			// other side of the diagonal
			side = (curve.orientation == C_BR || curve.orientation == C_TR) ? -1 : 1;
		}	else if(ccw(b, c, pt) < 0 || ccw(c, a, pt) < 0) {
			// same side of the diagonal, but outside curve hull
			side = (curve.orientation == C_BL || curve.orientation == C_TL) ? -1 : 1;
		}	else {
			// inside curve hull
			switch(curve.kind) {
				case C_LINE:
					side = 1;
					break;

				case C_QUADRATIC: {
					vec4 ph = vec4(pt.x, pt.y, 1, 1);
					vec4 klm = curve.M * ph;
					side = ((klm.x*klm.x - klm.y)*klm.z < 0) ? -1 : 1;
				} break;

				case C_CUBIC: {
					vec4 ph = vec4(pt.x, pt.y, 1, 1);
					vec4 klm = curve.M * ph;
					int sign = int(curve.negative);
					side = (sign * (klm.x*klm.x*klm.x - klm.y*klm.z) < 0)? -1 : 1;
				} break;
			}
		}
	}

	return(side);
}

// fill rules
#define RULE_ODD 1
#define RULE_EVEN 2
#define RULE_NONZERO 3
#define RULE_ZERO 4

bool intersects(int rule, int intersections) {
	if (rule == RULE_ODD) {
		return (intersections & 1) == 1;
	} else if (rule == RULE_EVEN) {
		return (intersections & 1) == 0;
	} else if (rule == RULE_NONZERO) {
		return intersections != 0;
	} else if (rule == RULE_ZERO) {
		return intersections == 0;
	}

	return false;
}

void main() {
	// vec2 px = gl_GlobalInvocationID.xy * gl_LocalInvocationID.xy;
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 px = gl_GlobalInvocationID.xy;

	uint tile_index = gl_WorkGroupID.x + gl_WorkGroupID.y * 25;
	Tile tile = tiles.data[tile_index];

	if (tile.skip) {
		return;
	}

	int winding_number = tile.winding_number;
	for (int i = 0; i < curves.data.length(); i += 1) {
		Implicit_Curve curve = curves.data[i];

		if (px.y > curve.box.y && px.y <= curve.box.w) {
			int count = curve_eval(curve, px);

			if (count < 0) {
				int increment = curve.going_up ? 1 : -1;
				winding_number += increment;
			}
		}
	}

	vec4 color = vec4(1, 1, 1, 1);

	if (intersects(RULE_ODD, winding_number)) {
	// if (intersects(RULE_EVEN, winding_number)) {
	// if (intersects(RULE_NONZERO, winding_number)) {
	// if (intersects(RULE_ZERO, winding_number)) {
		// color = vec4(1, 0, 0, 1);
		color = tile.color;
	}

	// imageStore(img_output, ivec2(int(px.x), int(px.y)), color);
	imageStore(img_output, pixel_coords, color);
}