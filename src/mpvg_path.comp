void main() {
	int path_index = int(gl_GlobalInvocationID.x);
	Path path = paths.data[path_index]; 

	vec4 clipped_box = vec4(
		max(path.box.x, path.clip.x),
		max(path.box.y, path.clip.y),
		path.box.z,
		min(path.box.w, path.clip.w)
	);
	ivec2 first_tile = ivec2(clipped_box.xy) / TILE_SIZE;
	ivec2 last_tile = ivec2(clipped_box.zw) / TILE_SIZE;

	int tiles_x = max(0, last_tile.x - first_tile.x + 1);
	int tiles_y = max(0, last_tile.y - first_tile.y + 1);
	int tile_count = tiles_x * tiles_y;

	int tile_queue_index = atomicAdd(indices.tile_queues, tile_count);
	int tile_op_index = atomicAdd(indices.tile_operations, tile_count * OPERATION_COUNT);

	// setup path queue data
	Path_Queue queue;
	queue.x = first_tile.x;
	queue.y = first_tile.y;
	queue.tiles_x = tiles_x;
	queue.tiles_y = tiles_y;

	queue.tile_queue_index = tile_queue_index;
	queue.index = path_index;
	path_queues.data[path_index] = queue;

	// init all tiles per path
	for (int i = tile_queue_index; i < tile_queue_index + tile_count; i += 1) {
		Tile_Queue tile;
		tile.tile_operation_start = tile_op_index + i * OPERATION_COUNT;
		tile.tile_operation_count = 0;
		tile.winding_offset = 0;
		tile.path_index = path_index;
		tile.tile_queue_next = -1;
		tile_queues.data[i] = tile;
	}
}